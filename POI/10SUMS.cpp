
#include <iostream>
#include <cstdio>
#include<list>
#include<iomanip>
#include<cmath>
#include <random>
#include<queue>
#include <functional>
#include<stdio.h>
#include<assert.h>
#include<stack>
#include<sstream>
#include <cstdlib>
#include<map>
#include<algorithm>
#include<iostream>
#include<set>
#include<utility>
#include<memory.h>
#include<string>
#include<vector>
#include <unordered_map>
#include<numeric>
using namespace std;
#define ios std::ios_base::sync_with_stdio(false);
#define ll  long long
#define pb push_back
#define fi(ss) freopen (ss,"r",stdin)
#define fo(ss) freopen (ss,"w",stdout)
#define sz(v)               ((int)((v).size()))
#define all(x)          (x).begin(),(x).end()
#define REP(i, v)       for(int i=0;i<sz(v);i++)
#define lp(i,n) for(int i = 0 ; i < n ; ++i)
#define hash ___hash
#define next ___next
#define prev ___prev
#define left ___left
typedef pair<int,ll> pii;
#define F second.first
#define S second.second
#define MP make_pair
int n,ships,len,k;
const int maxn = 5005;
int arr[maxn];
ll d[50005];
// Graphs - Dijikstra
//Question can be phrased as can we  write S as (a[m]) * k + y for any 1 <= m <= n and k >=0
// S = a[m] * k + y
// S mod a[m] = y mod % a[m]
// Lets say the smallest subset than can generate y mod % a[m] has actual sum X
// Case X > S no solution
// Case S >= X, keep adding a[m] till we reach it.

// How to find least X? Dijikstra on the modulo graph..graph has node 0,1,2,3,a[m] - 1
// edge between ith and jth node if (i + arr[i]) % a[m] == j % a[m] with cost arr[i]

// Case X == 0 can be generated by taking an empty subset
int main() {
	int n; cin >> n;
	for (int i = 0 ; i < n ; ++i) {
		scanf("%d",&arr[i]);
	}
	fill(d, d + 50001, 1LL << 52);
	priority_queue<pair<ll,ll>,vector<pair<ll,ll> >,greater<pair<ll,ll> > > pq;

	pq.push(pii(0,0));
	d[0] = 0;
	while (!pq.empty()) {
		pii r = pq.top(); pq.pop();
		int u = r.first,c = r.second;

		if (d[u] < c) {
			continue;
		}
		for (int i = 0 ; i < n ; ++i) {
			int v = (arr[i] + u) % arr[0];
			int cst = c + arr[i];
			if (d[v] > cst) {
				d[v] = cst;
				pq.push(pii(v,cst));
			}
		}
	}
	int k; cin >> k;
	while (k--) {
		int x;
		scanf("%d",&x);
		if (x == 0 || x >= d[x % arr[0]]) puts("TAK");
		else puts("NIE");
	}

}
