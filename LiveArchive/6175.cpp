#include <iostream>
#include <cstdio>
#include<list>
#include<iomanip>
#include<cmath>
#include<queue>
#include <functional>
#include<stdio.h>
#include<assert.h>
#include<stack>
#include<sstream>
#include <cstdlib>
#include<map>
#include<algorithm>
#include<iostream>
#include<set>
#include<utility>
#include<memory.h>
#include<string>
#include<vector>
#include<numeric>
using namespace std;
#define ll  long long
#define pb push_back
#define sz(v)               ((int)((v).size()))
#define all(x)          (x).begin(),(x).end()
#define REP(i, v)       for(int i=0;i<sz(v);i++)
typedef pair<int,int> pii;
#define ios std::ios_base::sync_with_stdio(false);
using namespace std;
int t;
double L,R;
// DP + probability

//This solution does not involve cycle handling, or arranging DP. Instead it just involves looking at the problem from a different angle after writing the direct O(N^3) DP.
//
//Let's consider writing the normal DP to the problem the state simply is (stepsLeft,currentPosition,maximumPositionVisited). This approach is easy to see and prove it's correct, but the problem is it takes O(N^3) time, and here N = 1000.
//
//Now using that dynamic programming, this problem can be mapped into..the expected position you end at in the array while ignoring any moves that put you below 0. The claim is, any path generated from the O(N^3) dp is generated by this O(N^2) dp, and any path in the O(N^2) dp is generated by the O(N^3), so they must count the same thing. 
//
//Now for proof, I don't have a formal one but if someone works it by hand, he can always see a way to map a path in both directions. The starting point of my thinking was "Values below zero never contribute to the state, can I remove them from the state?", and I worked my way through this to the recurrence. I also used the direct bruteforce dp to guess/verify some claims.
//
//My advice to whoever tried solving this, for expectation problems writing the "bruteforce solution" can usually help you guess a lot of things that are not related to cycle handling or linearity of expectation. Many problems are solved by mapping them to equivalent easier ones. You can also many times find "no thinking" optimizations that just appears from writing a DP (preferably bottom up), so try to always make a habit of writing them.position r
double dp2[1001][1001 + 1001];
double solve2(int rem,int r)
{
	if(rem == 0)
		return r;
	double &ret = dp2[rem][r + 1001];
	if(ret == ret)
		return ret;
	double left = 1.0*L*solve2(rem - 1,max(0,r - 1));
	double right =  R*solve2(rem - 1,r + 1);
	return ret =  left + right + (1.0 - R - L) * solve2(rem - 1,r);
	return ret;

}
int main()
{

	ios
	cin >> t;
	int tc;
	int steps;
	cout << fixed << setprecision(4);
	while(t--)
	{
		cin >> tc >> steps >> L >> R;
		//memset(dp2,-1,sizeof(dp2));
		if(L + R == 0)
			cout << "0.0000" << "\n";
		else
		{
			memset(dp2,-1,sizeof(dp2));
			cout << tc << " " << solve2(steps,0) << "\n";
		}

	}

}
